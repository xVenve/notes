\documentclass[12pt]{report} %fuente a 12pt

% MÁRGENES: 2,5 cm sup. e inf.; 3 cm izdo. y dcho.
\usepackage[
a4paper,
vmargin=2.5cm,
hmargin=3cm
]{geometry}

% INTERLINEADO: Estrecho (6 ptos./interlineado 1,15) o Moderado (6 ptos./interlineado 1,5)
\renewcommand{\baselinestretch}{1.15}
\parskip=6pt

% DEFINICIÓN DE COLORES para portada y listados de código
\usepackage[table]{xcolor}
\definecolor{azulUC3M}{RGB}{0,0,102}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

% Soporte para GENERAR PDF/A
\usepackage[a-1b]{pdfx}

% ENLACES
\usepackage{hyperref}
\hypersetup{colorlinks=true,
	linkcolor=black, % enlaces a partes del documento (p.e. índice) en color negro
	urlcolor=blue} % enlaces a recursos fuera del documento en azul

\usepackage{pdfpages}
\setlength{\parindent}{0em}

% EXPRESIONES MATEMATICAS
\usepackage{amsmath,amssymb,amsfonts,amsthm}

\usepackage{txfonts} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{tikz}
\usepackage{pgfplots}

\usepackage[spanish, es-tabla]{babel} 
\usepackage[babel, spanish=spanish]{csquotes}
\AtBeginEnvironment{quote}{\small}

% diseño de PIE DE PÁGINA
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\rfoot{\thepage}
\fancypagestyle{plain}{\pagestyle{fancy}}

% DISEÑO DE LOS TÍTULOS de las partes del trabajo (capítulos y epígrafes o subcapítulos)
\usepackage{titlesec}
\usepackage{titletoc}
\titleformat{\chapter}[block]
{\large\bfseries\filcenter}
{\thechapter.}
{5pt}
{\MakeUppercase}
{}
\titlespacing{\chapter}{0pt}{0pt}{*3}
\titlecontents{chapter}
[0pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace\uppercase}
{\contentsmargin{0pt}\uppercase}                        
{\titlerule*[.7pc]{.}\contentspage}                 

\titleformat{\section}
{\bfseries}
{\thesection.}
{5pt}
{}
\titlecontents{section}
[5pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace}
{\contentsmargin{0pt}}
{\titlerule*[.7pc]{.}\contentspage}

\titleformat{\subsection}
{\normalsize\bfseries}
{\thesubsection.}
{5pt}
{}
\titlecontents{subsection}
[10pt]                                               
{}
{\contentsmargin{0pt}                          
	\thecontentslabel.\enspace}
{\contentsmargin{0pt}}                        
{\titlerule*[.7pc]{.}\contentspage}  


% DISEÑO DE TABLAS.
\usepackage{multirow} % permite combinar celdas 
\usepackage{caption} % para personalizar el título de tablas y figuras
\usepackage{floatrow} % utilizamos este paquete y sus macros \ttabbox y \ffigbox para alinear los nombres de tablas y figuras de acuerdo con el estilo definido. Para su uso ver archivo de ejemplo 
\usepackage{array} % con este paquete podemos definir en la siguiente línea un nuevo tipo de columna para tablas: ancho personalizado y contenido centrado
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\DeclareCaptionFormat{upper}{#1#2\uppercase{#3}\par}

% Diseño de tabla para ingeniería
\captionsetup[table]{
	format=upper,
	name=TABLA,
	justification=centering,
	labelsep=period,
	width=.75\linewidth,
	labelfont=small,
	font=small,
}

% DISEÑO DE FIGURAS.
\usepackage{graphicx}
\graphicspath{{img/}} %ruta a la carpeta de imágenes

% Diseño de figuras para ingeniería
\captionsetup[figure]{
	format=hang,
	name=Fig.,
	singlelinecheck=off,
	labelsep=period,
	labelfont=small,
	font=small		
}

% NOTAS A PIE DE PÁGINA
\usepackage{chngcntr} %para numeración contínua de las notas al pie
\counterwithout{footnote}{chapter}

% LISTADOS DE CÓDIGO
% soporte y estilo para listados de código. Más información en https://es.wikibooks.org/wiki/Manual_de_LaTeX/Listados_de_código/Listados_con_listings
\usepackage{listings}

% definimos un estilo de listings
\lstdefinestyle{estilo}{ frame=Ltb,
	framerule=0pt,
	aboveskip=0.5cm,
	framextopmargin=3pt,
	framexbottommargin=3pt,
	framexleftmargin=0.4cm,
	framesep=0pt,
	rulesep=.4pt,
	backgroundcolor=\color{gray97},
	rulesepcolor=\color{black},
	%
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\bfseries,
	stringstyle=\ttfamily,
	showstringspaces = false,
	commentstyle=\color{gray45},     
	%
	numbers=left,
	numbersep=15pt,
	numberstyle=\tiny,
	numberfirstline = false,
	breaklines=true,
	xleftmargin=\parindent
}

\captionsetup[lstlisting]{font=small, labelsep=period}
% fijamos el estilo a utilizar 
\lstset{style=estilo}
\renewcommand{\lstlistingname}{\uppercase{Código}}

\pgfplotsset{compat=1.17} 
%-------------
%	DOCUMENTO
%-------------

\begin{document}
\pagenumbering{roman} % Se utilizan cifras romanas en la numeración de las páginas previas al cuerpo del trabajo
	
%----------
%	PORTADA
%----------	
\begin{titlepage}
	\begin{sffamily}
	\color{azulUC3M}
	\begin{center}
		\begin{figure}[H] %incluimos el logotipo de la Universidad
			\makebox[\textwidth][c]{\includegraphics[width=16cm]{Portada_Logo.png}}
		\end{figure}
		\vspace{2.5cm}
		\begin{Large}
			Grado en Ingeniería Informática\\			
			2020-2021\\
			\vspace{2cm}		
			\textsl{Apuntes}\\
			\bigskip
		\end{Large}
		 	{\Huge Diseño de Sistemas Operativos}\\
		 	\vspace*{0.5cm}
	 		\rule{10.5cm}{0.1mm}\\
			\vspace*{0.9cm}
			{\LARGE Jorge Rodríguez Fraile\footnote{\href{mailto:100405951@alumnos.uc3m.es}{Universidad: 100405951@alumnos.uc3m.es}  |  \href{mailto:jrf1616@gmail.com}{Personal: jrf1616@gmail.com}}}\\ 
			\vspace*{1cm}
	\end{center}
	\vfill
	\color{black}
		\includegraphics[width=4.2cm]{img/creativecommons.png}\\
		Esta obra se encuentra sujeta a la licencia Creative Commons\\ \textbf{Reconocimiento - No Comercial - Sin Obra Derivada}
	\end{sffamily}
\end{titlepage}

%----------
%	ÍNDICES
%----------	

%--
% Índice general
%-
\tableofcontents
\thispagestyle{fancy}

%--
% Índice de figuras. Si no se incluyen, comenta las líneas siguientes
%-
\listoffigures
\thispagestyle{fancy}

%--
% Índice de tablas. Si no se incluyen, comenta las líneas siguientes
%-
\listoftables
\thispagestyle{fancy}

%----------
%	TRABAJO
%----------	
\clearpage
\pagenumbering{arabic} % numeración con números arábigos para el resto de la publicación	


%----------
%	COMENZAR A ESCRIBIR AQUI
%----------	


\section{Información}

\begin{quote}
Teorías: Javier García Guzmán

Prácticas: Mat Max Montalvo Martínez
\end{quote}

\chapter{Tema 1: Arquitectura de Sistemas
IoT}


\textbf{IoT - Internet de las Cosas}: Consiste en conectar a internet
cualquier dispositivo, vehículo, edificios o en general objetos a los
que se les haya dotado de sensores, actuadores y conexión a la red. Lo
que les permite obtener e intercambiar información. Red de objetos
conectados a internet que aporta valor añadidos a los usuarios que
interactúan con ellos.

Consiste en añadir \textbf{inteligencia computacional} a dispositivos
para mejorar las funcionalidades.

Permite que los dispositivos puedan intercambiar información.

Se busca que sean pequeños y tengan un chip que les permita
\textbf{conectarse a la red} y operar en ella. Lo estandarizo IBM.

El \textbf{top 6 áreas} de aplicación de IoT:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}

\item
  \textbf{Industrial/Fabricación}: Automatizar, controlar la
  distribución, gestión de instalaciones.
\item
  \textbf{Transporte/Movilidad:} Coches, tráfico en ciudad, vehículos de
  transporte masivo y transporte industrial.
\item
  \textbf{Energía/Gestión eléctrica}: Predecir consumo, personalizar,
  bien estar de los ocupantes, monitorizar el consumo detallado,
  instalaciones con sensores.
\item
  \textbf{Gestión de inventarios/Comercial}: Saber cuánto queda y pedir,
  facilitar compras.
\item
  \textbf{Ciudad}: Recoge muchas áreas; basura, vigilancia, trafico,
  etc.
\item
  \textbf{Salud:} Investigación, la forma de tratar, las emergencias,
  distribución de información médica y dispositivos.
\end{enumerate}

\textbf{Agricultura de precisión}: Según las previsiones ambientales y
meteorológicas, plagas y demás se calcula el mejor momento para sembrar.
Además, cuando ya está plantado, las condiciones del suelo, cuando regar
y abonar las tierras, así como la recolecta.

\newpage

\section{En IoT de vehículos hay distintos
niveles}

\textbf{0}: Sin automatización.

\textbf{1}: Asistencia en la conducción.

\textbf{2}: Control de carril, lateral y longitudinal.

\textbf{3}: Conducción autónoma, pero el conductor en su puesto, para
riesgos.

\textbf{4}: Conducción autónoma, pero el conductor en su puesto,
supervisar.

\textbf{5}: Conducción totalmente autónoma, sin conductor.

\section{Elementos IoT}

\textbf{Colector}: Recogen información, sensores, o se activan,
actuadores, que se intercambian en internet.

\textbf{Transmisor}: Puertas de enlace, pasarelas, pasan los datos a la
red desde los dispositivos.

\textbf{Agregación + Distribución}: Calculo y procesamiento de la
información.

\textbf{Consumidor}: Los usuarios/clientes acceden a los datos.

\section{Evolución}

3 generaciones.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{RFID y sensores}

  Tecnología de detección por radiofrecuencia.

  Las cosas contengan información, las etiquetas (como NFC, se
  estandarizó para indicar que datos contiene) y tener un dispositivo
  que al acercarlo podamos leerla.
\item
  \textbf{Web services e inter-networking} (2004-2012): Interconexión
  completa de las cosas y la red de las cosas.

  IPv4, HTTP, Bluetooth, TCP, UDP, etc.

  Pasan a tener una manera fácil de conectarse los dispositivos entre sí
  o con internet.
\item
  \textbf{Social, Cloud \& ICN:} La era de la computación en la nube y
  la Internet del futuro.

  En esta generación la lógica pasa a estar en la nube, no en el
  dispositivo.

  Gestión de grandes cantidades de información.

  Seguridad, evitar accesos fraudulentos.
\end{enumerate}

\section{Arquitectura de un Sistema IoT}
\begin{description}
	\item[Dispositivos (Devices)] Sensores y actuadores FÍSICOS, que
	normalmente tienen un microprocesador, que mide el medio físico y
	transforma las mediciones a señales digitales. Su función es tomar
	medidas y procesarlas, pero su función no puede ser solo transmitir la
	información.
	
	Actuador, Sensores, LED, LCD, Beacon (la parte dispositivo), Termostato,
	RFID, Trampa para ratones inteligente, Dispositivos embebidos, etc.
	\item[Pasarela (Gateway)] Dispositivo o protocolo con la capacidad de
	comunicar con internet los dispositivos, para transmitir los datos
	tomados. Su única función es transmitir.
	
	Router, Wifi, GSM, Bluetooth, Zigbee, Raspberry a veces, AMQP, CoAP,
	LoRaWAN (sistema de radio), Wimax.
	
	Un móvil está entre Device y Gateway.
	\item[Plataforma IoT (IoT Platform)] Conjunto de servicios
	orquestados para gestionar una gran red de dispositivos interconectados
	y que proporcionan información a aplicaciones u otros tipos de sistemas
	de información. Gestiona y almacena grandes cantidades de datos y las
	redirige. Funciona como middleware.
	
	Es una nube de servidores que dan servicios:
	
	\begin{enumerate}
		\item \textbf{Message broker y Message bus}: Se encarga de conectar los
		dispositivos físicos con los distintos procesos que forman parte de la
		red de IoT. Manda los datos a todos los que estén conectados a su bus,
		suscritos por API Rest.
		\item
		\textbf{Message router}: Está suscrito al message broker, los mensajes
		que recibe los enriquece; dando información semántica, de contexto, de
		estado y los reenvía a aquellos componentes que van a gestionar la
		lógica de las aplicaciones relacionadas con la nube IoT. Otra cosa que
		hace es transformar datos, descomprimir y decodificar datos para
		hacerlos más fáciles de procesar y tratar.
		\item
		\textbf{Rest API}: Interfaz que usan otros programas para obtener los
		servicios o las funcionalidades de un componente. Esta API se
		caracteriza por ser accesible por http e independiente del estado del
		sistema.
		\item
		\textbf{Data Management}: Para almacenar y gestionar los datos tomados
		en la red.
		\item
		\textbf{Rule engine}: Permite monitorear los mensajes recibidos desde
		el router y permite lanzar distintas acciones en distintos elementos.
		Decide que acción tomar.
		
		Ejem: Si se abre la puerta, entonces avisar de intruso.
		\item
		\textbf{Microservicios}: Proporciona funcionalidades muy específicas a
		través de una interfaz API Rest bien definidas mediante un contrato de
		datos. Muchos los coordina el rule engine. Se busca que este muy
		cohesionado y poco acoplado.
		
		Ejem: El que actualiza la estación meteorológica en el móvil, es un
		proceso muy concreto.
		\item
		\textbf{Device manager}: Permite monitorizar algunos elementos de los
		sensores físicos como si está activo, la batería o si está conectado a
		la red.
		\item
		\textbf{App y User management}: Sistema de permisos que identifica y
		gestiona el acceso de usuarios y aplicaciones.
	\end{enumerate}

	\item[Aplicación (Application)] La interfaz que el usuario utiliza
	para controlar el sistema.

\end{description}

\textbf{iBeacon} es un ejemplo de protocolo y \textbf{Beacon} es el
dispositivo. Ambos están relacionados con dispositivos.

\textbf{Small Data}: Que solo proporcione la información de valor
añadido. Es un conjunto de datos con un volumen y un formato que hacen
que los datos sean accesibles, informativos y procesables.

\textbf{Wimax}: Conjunto de tecnologías y protocolos para aumentar el
alcance de las redes inalámbricas (en vez de 30 metros, 40 kilómetros).

\chapter{Tema 2: Sensores y
Actuadores}


Hasta la sección `Up to Functional examples
(putting it all together)' incluida.

\section{Sensores}

Conjunto de componentes electrónicos capaces de detectar cambios físicos
en el entorno y enviar información a otros componentes electrónicos,
generalmente un procesador de computadora.

\textbf{Ejemplos}: Sensor de luz (LDR), sensor de ultrasonidos,
giroscopio, fototransistor, Reed switch, \ldots{}

Los sensores se pueden clasificar en tipos según lo que miden: Gases,
velocidad, flujo, fugas, movimiento, electricidad, \ldots{}

Según la señal que produce:

\begin{itemize}

\item
  \textbf{Analógico}: Produce voltaje analógico constante de lo medido.
  El grafico de voltaje sobre el tiempo debe ser continuo y suave.

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Diagrama de voltaje Sensor Analógico}}
	{\includegraphics[scale=.5]{image-20210307210139988.png}}
\end{figure}

    Sensor de presión, sensor de luz, sensor de temperatura,
    acelerómetro, sensor de sonido.

\item
  \textbf{Digital}: Produce un voltaje discreto, por lo general tendrá
  uno u otro de dos valores, 0V (apagado) a 5V (encendido). Gracias a la
  miniaturización hay más dado que se puede introducir un conversor.

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Diagrama de voltaje Sensor Digital}}
	{\includegraphics[scale=.5]{image-20210307210421078.png}}
\end{figure}

    Sensor de ultrasonidos, sensor de infrarrojos, acelerómetro, sensor
    de sonido (suele ser analógico), sensor de temperatura.
\end{itemize}

Según si necesitan energía:

\begin{itemize}

\item
  \textbf{Sensor activo}: Siempre \textbf{necesitan} su propia fuente de
  energía.

  \begin{itemize}
  
  \item
    Sensor de ultrasonidos, radar, LiDAR, sensor de humedad, cámara
    infrarroja.
  \end{itemize}
\item
  \textbf{Sensor pasivo}: \textbf{No necesitan} una fuente de energía,
  usan factores externos para alimentarse.

  \begin{itemize}
  
  \item
    Sensor infrarrojo (fotodiodo infrarrojo), sensor PIR, sensor de luz
    (LDR)
  \end{itemize}
\end{itemize}

\textbf{Sensor piezoeléctrico:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}

\item
  Un cristal piezoeléctrico se coloca entre dos placas de metal que
  están en perfecto equilibrio y conduce ninguna corriente eléctrica.
\item
  Las placas de metal aplican tensión o fuerza mecánica sobre el
  material que hace que las cargas eléctricas del cristal se
  desequilibren.
\item
  Las placas de metal recogen esas cargas y producen un voltaje y envía
  una corriente eléctrica a través de un circuito.
\end{enumerate}

\section{Actuadores}

Cualquier dispositivo capaz de intervenir para cambiar las condiciones
físicas del entorno generando los datos.

\textbf{Ejemplos}: Display, LED, servomotor, motor de paso a paso,
Relay, solenoide, actuadores lineales, \ldots{}

\section{Factores de selección de Sensores y
Actuadores}

\textbf{Factores ambientales}: Temperatura, Humedad, Corrosión,
Interferencia electromagnética, Tamaño, Rudeza y Consumo de energía.

\textbf{Factores económicos}: Coste, Disponibilidad y Tiempo de vida.

\textbf{Factores característicos del sensor}: Sensibilidad, Rango,
Estabilidad, Repetibilidad, Rango de error, Tiempo de respuesta y
Linealidad.

\section{Preguntas Test 2}
\begin{itemize}
	\item La tercera generación de IoT se caracteriza por:
	
	c. la forma de construir servicios de Internet y permitir un acceso ubicuo, conveniente y bajo demanda a ellos (computación en la nube).

	\item ¿Cuál de los siguientes NO es un impulsor del mercado de Internet de las cosas (IoT)?
	
	c. Adopción global de redes no IP 

	\item Seleccione la respuesta correcta con respecto a la prevalencia de sensores:

	b. Los sensores de temperatura son los sensores más comunes. 

	\item ¿Con qué sensor se realiza la monitorización de máquinas, engranajes y objetos?

	Sensor de proximidad

	\item Seleccione la aplicación de IoT fuera del ámbito agrícola:

	b. Monitorización de parámetros fisiológicos de personas 
	
	\item Message Broker y Message Bus tratan con ...
	
	d. ... la transmisión de mensajes con el mundo físico, especialmente dispositivos y sensores heterogéneos. 

	\item Un ejemplo de sensor activo es:

	b. Sensor de humedad 
	
	\item Un \_\_\_\_\_\_\_\_ es un resistor térmicamente sensible que exhibe un gran cambio de resistencia.

	b. Termistor.

	\item ¿Qué permite que los dispositivos digitales se interconecten y transmitan datos?

	c. Una red 

	\item Seleccione la respuesta correcta con respecto a un sensor analógico:

	d. El gráfico de tiempo versus voltaje de una señal analógica debe ser uniforme y continuo. 

\end{itemize}

\chapter{Tema 3: Sistemas operativos embebidos para Dispositivos
IoT}

\section{¿Que es un sistema embebido o
integrado?}

Sistemas basados en computadora que no parecen ser computadoras, la complejidad esta oculta al usuario.

Son sistemas que integran uno o más sensores y que son capaces de
comunicarse con la red, con capacidades limitadas, por lo que están
entre la capa de Dispositivos y Pasarelas.

Se aplican sobre cosas cotidianas para mejorarla, pero no
proporciona una mayor complejidad del sistema, permite realizar la
mismas funciones o alguna más pero mejor.

Todo dispositivo IoT es un sistema embebido, pero no todo sistema
embebido es IoT. Los sistemas IoT son accesibles a través de internet y
puede enviar la información que registra en tiempo real por internet.

\textbf{Los sistema embebidos o integrados} son aquellos capaces de
interactuar con el usuario (a través de una interfaz simple) o con otra herramienta invisible para el usuario. Es decir, no tiene por qué haber una interacción directa con el usuario (un pendrive se enchufa al ordenador, no al usuario)

\begin{itemize}

\item
  Ejem: Memoria flash, pendrive, sistema antibloqueo de ruedas.
\end{itemize}

\textbf{Un sistema IoT} es aquel con el que podemos interactuar
directamente, acceder a sus datos o que nos los muestre, y tiene
capacidad de internet. Hoy en día es muy barato transformar un sistema
embebido a IoT.

\textbf{Factor clave de los sistemas embebidos}:

\begin{itemize}

\item
  La \textbf{eficiencia}, velocidad a la que responde o realiza la tarea
  específica. Para alcanzar la eficiencia \textbf{se cambia el enfoque
  de la programación}, no hay recursos ilimitados y hay que adaptarlo
  para que consuma poca energía y memoria.
\item
  El \textbf{consumo de energía}, si se encuentra en algún lugar remoto
  y tiene una batería debe durar mucho.
\item
  El \textbf{uso de memoria}, ya que afecta al rendimiento y son caras.
\item
  \textbf{Precio}, ya que ante productos similares se elige el más
  barato.
\item
  \textbf{Sistema critico}, aquel del que el tiempo de respuesta es
  clave, que si falla puede correr riesgo alguna vida humana.
\end{itemize}

\textbf{Fuertes restricciones}: Coste de fabricación, Coste de diseño, Rendimiento, Energía, Tiempo de comercialización.

\textbf{No podemos aprovechar la Ley de Moore}, nos tenemos que ajustar
al sistema como está actualmente, no podemos esperar a que pase el
tiempo suficiente para que compremos otro que de mejor rendimiento. Hay
que diseñar sistemas que sean rápidos con la tecnología actual y pueda
durar en el un largo periodo de tiempo.

\textbf{Del cuestionario:}

\begin{itemize}

\item
  Se dice que un \textbf{sistema es en tiempo real si el tiempo de
  respuesta es crítico}. Como el sistema ABS o de detección de colisión.
\item
  Es cierto que la mayoría de los sistemas informáticos integrados están
  diseñados por equipos pequeños con plazo ajustados.
\item
  Un sistema en tiempo real se define como un sistema cuya corrección de
  la puntualidad de su respuesta.
\item
  Es cierto que un sistema integrado puede definirse como un sistema de
  control o un sistema informático diseñado para realizar una tarea
  específica.
\end{itemize}

\subsection{Ordenador personal vs. Sistema
embebido}

\textbf{Sistema embebido}: Son específicos de una aplicación, se
focalizan en una tarea o conjunto de tareas relacionadas en todo
momento.

\begin{itemize}

\item
  Todos los recursos están dirigidos a realizar esa tarea, por lo que la
  realiza de manera eficiente, pero no le sobran recursos y realizar alguna otra tarea es
  muy difícil o imposible. El software y hardware lo diseñan juntos por
  lo que es más eficiente y fiable, se adaptan al hardware
  perfectamente.
\item
  Utilizan arquitecturas muy variadas, con diferentes CPU, periféricos,
  SO y prioridades de diseño.
\item
  El tiempo de arranque es casi instantáneo, medido en segundos.
\end{itemize}

\textbf{Computadora de escritorio}: Puede ejecutar cualquier clase se
aplicación según las necesidades del usuario.

\begin{itemize}

\item
  Está listo para cualquier tarea por lo que consume más energía y
  recursos. El diseño de hardware lo desarrollan empresas distintas, por
  lo que sobran recursos o se requiere más de los que hay, sobreestima.
  Además, se pueden ampliar fácil y económicamente si es necesario.
\item
  Usan una arquitectura muy similar todos y ejecutan software en
  sistemas idénticos.
\item
  El tiempo de inicio se puede medir en minutos cuando se carga desde
  disco.
\end{itemize}

\textbf{Del cuestionario:}

\begin{itemize}

\item
  Un sistema embebido no necesita interacción humana para realizar
  tareas.
\item
  Un sistema embebido necesita menos potencia operativa que una
  computadora.
\item
  Los ordenadores se pueden reprogramar para un nuevo propósito.
\item
  Los ordenadores son difíciles cuando se usan, en comparación con un
  sistema embebido.
\item
  Los ordenadores pueden realizar muchas tareas.
\end{itemize}		

\section{Estructura de un sistema embebido}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Estructura genérica de un Sistema Embebido}}
	{\includegraphics[scale=.35]{2021-03-19 16_58_28-DSO Elementos Sistema embebido.mkv.png}}
\end{figure}

\begin{description}
	\item[Microcontrolador] Es el componente que ejecuta un programa en un sistema integrado, y se encuentra en la zona central, se encarga de realizar el procesamiento. 
	
	Conectado a otros componentes del hardware, envía órdenes a los actuadores y recibe datos de los sensores. 
	
	Consta de CPU, RAM, ROM, puertos E/S y temporizadores.
	
	Mas lento que un microprocesador, menos memoria y menos funciones.
	
	Requiere ser programado, se debe escribir el código del programa que va a realizar. El código se escribe en el host, un ordenador de sobremesa o laptop, y después se transfiere el programa del host al microcontrolador.
	\item[Cajas negras] Realizan parte del trabajo del microprocesador para reducir la carga, algunas tareas específicas. Algunos ejemplos son:
	\begin{description}
		\item[IP Core] Circuito integrado que desempeña una función que interactúa con el microcontrolador, y son baratos en un volumen alto. Muy útiles para tareas comunes como controlador de network (Ethernet, CAN)  o de audio/video (Audio Códec, Controlador VGA). Necesita interactuar con el microprocesador y se siguen unos protocolos de comunicación. 

		\item[FPGA - Field Programmable Gate Array] Matriz de puertas lógicas programable en campo, es un chip con una red de puertas de memoria RAM que se pueden configurar (establecer las conexiones entre chips o puertas), para realizar una serie de tareas, como puede ser filtrar una señal o comprimir video. Es más rápido que software, pero más lento que ASIC. 

		\item[DSP] Procesadores y compresores de señales digitales, tanto de audio como de video. Son más económicos que los procesadores, pero tiene capacidades más limitadas.

	\end{description}
	\item[Conversores] Analógico-Digital sale de sensor, izquierda y el Digital-Analógico va al actuador, derecha. Los analógico a digital son muy comunes, porque los sensores son analógicos y el microcontrolador es digital.
	\item[Sensores y actuadores] Toma medidas del medio que rodea al dispositivo y puede alterar el entorno. Sensores a la izquierda y actuadores a la derecha.
\end{description}

\section{Ejemplos de Sistemas embebidos que usamos}
\subsection{Arduino}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Estructura Arduino}}
	{\includegraphics[scale=.5]{2021-03-19 17_31_12-DSO Elementos Sistema embebido.mkv.png}}
\end{figure}


Es una plataforma de código abierto sed para construir proyecto de electrónica.	Consta de una placa de circuito programable física (microcontrolador) y una pieza de software, o IDE (entorno de desarrollo) que se ejecuta en una computadora portátil o computadora personal utilizada para escribir y cargar código de computadora en la física. Tiene pines analógicos y digitales.
	
No necesita una pieza software separada para cargar un nuevo código en la placa.
	
Utiliza una versión simplificada de C++, lo que lo hace más fácil de aprender.
	
\textbf{Razones por la que se usa:} Es de código abierto, económico, multiplataforma, prototipos rápidos, entorno programable más simple y claro. Algunas también cuentan con conexión a Internet incorporada o la posibilidad de conectividad externa.
	
\textbf{Razones para no utilizarlos:} Poca memoria para datos y RAM, procesamiento, arquitectura basada en 8 bits, caro cuando se necesita a gran escala, mala calidad/precio, las empresas no les gusta que sea open source, no está aliado con proveedores y no da garantías.

\subsection{Raspberry Pi}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Estructura Raspberry Pi}}
	{\includegraphics[scale=.4]{2021-03-19 17_48_46-DSO Elementos Sistema embebido.mkv.png}}
\end{figure}

Es una computadora de bajo costo del tamaño de una tarjeta de crédito que se conecta a un monitor de computadora o televisor y utiliza un teclado y un mouse estándar.

La Raspberry PI tiene una conexión GPIO de 40 pines, lo que facilita la conexión con el mundo exterior.


\begin{description}
	\item[GPIO] Significa entrada/salida de uso general. Estos pines son una interfaz física entre Raspberry Pi y el mundo exterior. 
	
	El Pi puede recibir información de sensores y actuadores, y controlar actuadores como LED, ejecutar motores y muchas otras cosas.
	
	Hay 40 pines y proporcionan varias funciones diferentes. 
	\begin{itemize}
		\item Los pines 27 y 28, ID SD e ID SC, son para conectar una EEPROM.
		\item Pines 8 y 10, GPIO 14 y 15, son para comunicación UART puerto serie que transmite poca información (baja frecuencia), como USB, RFID, Bluetooth, GPS, GSM o GPRDS.
		\item GPIO 2 y 3 (clock) se usan para I2C, comunicación entre placas, como un LCD, otras placas base (Raspberry, Arduino, ...) o un reloj de tiempo real.
		\item GPIO 7, 8, 9, 10 y 11 implementan otro mecanismo de comunicación el SPI, que es la evolución del protocolo I2C, su función es comunicar full duplex, como SSD card, IP Core o Memoria Flash.
	\end{itemize}
		
\end{description}  
\textbf{Del cuestionario:}

\begin{itemize}

\item Cual de los siguientes NO es un beneficio de usar un sistema operativo? 

La frecuencia del reloj del microprocesador se puede aumentar significativamente.
\end{itemize}
	
\subsection{Raspberry Pi vs. Arduino}
\begin{itemize}
	\item Raspberry usa un procesador de propósito general y Arduino un microprocesador.
	\item Raspberry Pi es más rápido (1.4GHz vs 16MHz).
	\item Raspberry Pi puede administrar un espacio de direcciones más grande (procesador de 64 bits, frente a 8 bits).
	\item Raspberry Pi tiene más memoria: Arduino tiene 32K Flash, 2K RAM, 1K EPROM; y Raspberry Pi SRAM de 1 Gb, Micro SD.
	\item Raspberry Pi tiene niveles de voltaje de E/S más bajos (3.3v frente a 5v)
\end{itemize}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Raspberry Pi vs. Arduino}}
	{\includegraphics[scale=.62]{2021-03-24 19_03_44-Tema 03 - Gateways IoT - Sistemas Embebidos.png}}
\end{figure}

\subsection{¿Es Raspberry Pi un dispositivo de IoT?}

\textbf{Similitudes:}
\begin{itemize}
	\item Conectividad de red e inteligencia computacional.
	\item Pequeño y barato (en relación con una PC).
	\item Puede interactuar directamente con sensores/actuadores a través de pines.
\end{itemize}


\textbf{Diferencias:}
\begin{itemize}
	\item La interfaz puede ser exactamente la misma que la de una PC con Linux: Las complejidades del sistema pueden ser visibles.
\end{itemize}

\section{Sistemas Operativos embebidos}
Es una parte opcional de la pila de software de un dispositivo, lo que significa que no todos los sistemas integrados tienen uno.

Proporciona una capa de abstracción para el software sobre el sistema operativo.
Administra los diversos recursos de hardware y software del sistema para garantizar que toto el sistema funciona de manera eficiente y confiable.

En nuestro caso tiene como función proporcionar una interfaz común (no tiene por qué ser grafica) y abstracta a todos los elementos de hardware y que sea capaz de que las aplicaciones que se van a desarrollar sobre él se programen de la manera más fácilmente posible.

El núcleo del sistema operativo es el kernel, pero depende el SO embebido tendremos distintos tipos, algunos más robustos que tienen incluso interfaz gráfica o más ligeros que tienen la gestión de procesos y memoria.

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Capas Sistema Operativo}}
	{\includegraphics[scale=.6]{2021-03-25 09_19_18-2021-03-24 16-59-20.mkv.png}}
\end{figure}

\subsection{Principales Sistemas Operativos embebidos actuales} 
Zephyr, Micrium, RTOS (Real Time Operative Systems), R IOT, VxWorks, ThreadX, MircroEJ, TinyOS, APACHE, ARMmbed, Contiki, Nucleus, Windows IoT, snappy, android things, Mongoose o mynewt.

\subsection{Requisitos de un Sistema Operativo Embebido}
\textbf{Restricciones de Hardware Heterogéneos}
\begin{itemize}	
	\item Requisitos de CPU: Las operaciones no deben ser de carga alta, hay baja frecuencia.
	\item Requisito de Memoria: Suelen tener poca memoria (Arduino 4K).
	\item Características limitadas
	\item Soporte a Plataformas
\end{itemize}

\textbf{Autonomía}
\begin{itemize}	
	\item Eficiencia energética: Como suspenderse bajo inactividad o protocolos de comunicación de bajo consumo.
	\item Stack de Red Adaptativo
	\item Fiabilidad, cuanto más tiempo pase antes de que necesite asistencia o ser remplazado, más autonomía.
\end{itemize}

\textbf{Programabilidad:} 
\begin{itemize}
	\item API estándar: Gestionar procesos, servicios, tareas, threads, interrupciones, shockets...
	\item Lenguajes de Programación estándar, que nos permita utilizar la API para desarrollar aplicaciones. 
\end{itemize}

\subsection{Capa de Software del Sistema}
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Modelo General SO embebido}}
	{\includegraphics[scale=.5]{2021-03-25 10_06_39-2021-03-24 16-59-20.mkv.png}}
\end{figure}

Es un conjunto de librerías que proporcionan 3 grandes áreas de procesamiento: Gestión de tareas, de memoria y de Entrada/Salida. Dependiendo del SO puede incluir los drivers de los distintos dispositivos hardware que conectamos, o servicios de programación más refinados para tareas más complejas en el Middleware.

\subsubsection{Controladores de Dispositivos - Device Drivers}
Son las bibliotecas de software que sirven para interactuar con los distintos elementos hardware. Inicializan el hardware y administran el acceso al mismo mediante capas superiores de software. Por ejemplos los de GPIO de Raspberry Pi.

Todos los controladores de dispositivos generalmente se componen de todas o una combinación de las siguientes funciones: Inicio, Apagado, Lectura, Escritura, Deshabilitar o Habilitar hardware.

\textbf{Acciones:}
\begin{itemize}
	\item \textbf{Hardware Startup:} Inicialización del hardware tras el encendido o el restablecimiento.
	\item \textbf{Hardware Shutdown:} Configurando el hardware en su estado PowerOFF.
	\item \textbf{Hardware Disable:} Permitir que otro software desactive el hardware sobre la marcha.
	\item \textbf{Hardware Enable:} Permitir que otro software active el hardware sobre la marcha.
	\item \textbf{Hardware Acquire:} Permitir que otro software obtenga acceso singular (bloqueo) al hardware.
	\item \textbf{Hardware Release:} Permitir que otro software libere (desbloquee) hardware. 
	\item \textbf{Hardware Read:} Permitir que otro software lea datos en el hardware.
	\item \textbf{Hardware Write:} Permitir que otro software escriba datos en el hardware.
	\item \textbf{Hardware Install:} Permitir que otro software instale nuevo hardware sobre la marcha.  
	\item \textbf{Hardware Uninstall:} Permitir que otro software quite hardware instalado sobre la marcha.   
	\item \textbf{Hardware Mapping:} Permite el mapeo de direcciones hacia y desde dispositivos de almacenamiento de hardware para leer y escribir datos.
	\item \textbf{Hardware Unmapping:} Permitiendo eliminar bloques de datos de dispositivos de almacenamiento de hardware.
\end{itemize}

\subsubsection{Kernel}

\begin{description}
	\item[Gestión de Procesos - Process Management] Como el sistema operativo administra y ve otro software en el sistema embebido. 

	\begin{description}
		\item[Threads] Crear hilos, lanzarlos, controlarlos, terminarlos o sincronizarlos. Estos nos permiten tener varias tareas en ejecución de manera concurrente. 
		\item[Semaphores] Primitiva de sincronización, para evitar las condiciones de carrera.
		\item[Priority scheduling] Determinar el orden en el que los hilos entran a ejecutar.
		\item[Real-time signal extension] Interrupciones y señales, para activar notificaciones de aplicaciones asíncronamente.
		\item[Timers] Mecanismo de notificación que nos avisa cuando se ha alcanzado o superado un determinado tiempo.
		\item[IPC] Comunicación Inter-Proceso.
	\end{description}

	\paragraph{Gestión de multitareas y de procesos en sistemas embebidos}

	Una de las principales diferencias de los SO embebidos es que no tenemos múltiples núcleos, donde en cada núcleo se podría ejecutar distintas cosas, lo que tenemos es un único núcleo que ejecuta una única tarea a la vez y va asignando rodajas a los procesos para dar la sensación de que se ejecutan varias en paralelo.

	Como no se pueden hacer múltiples tareas a la vez, por lo que debemos tener un mecanismo que administre y planifique el orden de ejecución de los distintos procesos. Indicar cuando entran y salen, y el paso de datos.
	
	La Raspberry Pi como tiene 4 núcleos se considera nano ordenador, no sistema embebido.
	
	
	\paragraph{Implementación de procesos en Sistemas Operativos embebidos}
	
	Las tareas están estructuradas como una jerarquía de tareas principales y secundarias, y cuando se inicia el kernel embebido, solo existe una tarea de la que se lanzan todas las demás.
	
	
	\paragraph{Creación de tareas}
	La creación de tareas en sistemas operativos integrados se basa principalmente en dos modelos, fork/exec (deriva del IEEE/ISO POSIX) y spawn (deriva de fork/exec).

	\begin{itemize}
		\item \textbf{fork:} Crea una copia del espacio de memoria de la tarea principal en lo que se asigna para la tarea secundaria, lo que permite que la tarea secundaria herede varias propiedades, como el código del programa y las variables, de la tarea principal.
		\item \textbf{exec:} Se utiliza para eliminar explícitamente del espacio de memoria de la tarea secundaria cualquier referencia al programa principal y establece el nuevo código de programa que pertenece a la tarea secundaria para que se ejecute.
		\item \textbf{spawn model:} Crea un espacio de direcciones completamente nuevo para la tarea secundaria. La llamada al "modelo de generación" permite definir el nuevo programa y los argumentos para la tarea secundaria. 
	\end{itemize}

	\textbf{Spawn model:} No tiene espacios duplicados, optimiza el espacio de memoria, no gasta tanta memoria como fork/exec. Es más complicado compartir propiedades entre procesos.
	
	\textbf{fork/exec:} Nos permite coordinar de una manera más sencilla y compartir propiedades, pero es más lenta y requiere más memoria (que es limitada) por que tiene que copiar y eliminar.
	
	\paragraph{Planificador de Tareas - Scheduler:} Es el que nos dice cuándo y cuanto tiene va a ejecutar cada una de las tareas, va metiendo y sacando de la CPU. El programador clasifica las tareas en READY, RUNNING y BLOCK.
	
	\paragraph{Factores clave del Scheduling}
	Lo critico es la efectividad y la eficiencia en cuanto al tiempo de respuesta en cambiar entre tareas y elegir cual es la va a continuación.
	\begin{itemize}
		\item 	\textbf{Tiempo de respuesta - Response Time:} Tiempo para que el programador haga que el contexto cambie a una tarea lista e incluye el tiempo de espera de la tarea en cola lista.
		\item 	\textbf{Turnaround time:} El tiempo que tarda un proceso en completarse.
		\item 	\textbf{Overhead:} El tiempo y los datos necesarios para determinar que tareas se ejecutan a continuación.
		\item 	\textbf{Fairness:} Ser capaz de realizar una partición equitativa entre todas las tareas que están pendientes de ejecución. ?Cuales son los factores determinantes en cuanto a qué procesos llegan a ejecutarse?
		\item 	\textbf{Throughput:} Procesar tantas tareas como sea posible en un periodo de tiempo determinado. tareas por unidad de tiempo.
		\item 	\textbf{Starvation:} Donde una tarea nunca llega a ejecutarse, nunca recibe una rodaja de tiempo.
	\end{itemize}

	
	\paragraph{Preventivo vs. No preventivo}

	Utilizar el término más parecido a la terminología inglesa, Expropiativo y No expropiativo.

	\begin{itemize}
		\item \textbf{Non-pre-emptive - No expropiativo - Apropiativo:} No se le puede expulsar. Las tareas reciben el control de la CPU maestra hasta que finalizan su ejecución, independientemente del tiempo o la importancia de las otras tareas que están en espera.
		
		Ejemplos: FCFS, SPF o SJF, Prioridades

		\item \textbf{Pre-emptive - Expropiativo - No apropiativo:} Se les puede expulsar de las CPU cuando acaba su rodaja, se dividen los procesos en rodajas de duración fija. El SO fuerza el cambio de contexto en una tarea, ya sea que una tarea en ejecución haya terminado de ejecutarse o este cooperando con el cambio de contexto.	

		Ejemplos: Round Robin, SRTF, Colas Multinivel
	\end{itemize}
	
	\paragraph{Planificación e Raspberry Pi OS}
	\begin{itemize}
		\item 	Opera en todos los componentes.
		\item 	Solo se ejecuta una tarea a la vez.
		\item 	El planificador es un componente independiente.
		\item 	El programador predeterminado es una cola FIFO simple.
		\item 	La planificación es consciente de la energía, y pone el procesador en suspensión cuando no hay ninguna tarea en la cola.
	\end{itemize}

	\paragraph{Manejo de señales e interrupciones} Cuando llega una interrupción externa, saca el proceso de la CPU y atiende la interrupción ejecutando la rutina correspondiente, y vuelve al proceso previo.

	\paragraph{Sincronización y comunicación entre tareas} Nos permite que las distintas subtareas compartan datos, la manera más sencilla es utilizando espacios de memoria compartidos.

	\item[Memory Management] El espacio del sistema embebido es compartido por todos los diferentes procesos, por lo que es necesario administrar el acceso y la asignación de partes del espacio de memoria. Los procesos de memoria para tener en cuenta:
	\begin{description}
		\item[Process memory locking] Ser capaz de bloquear y evitar los accesos indebidos al espacio de memoria de otros procesos.
		\item[Memory mapped files] Llevar a memorias secundarias algunos mapas o páginas que tenga en función de las restricciones.
		\item[Shared memory object] Implementar variables, objetos o espacios de memoria compartidos en distintos procesos para favorecer su sincronización.
	\end{description}

	\paragraph{Modo de usuario vs. Modo kernel}
		La forma en que los sistemas operativos administran el espacio de memoria lógica difiere de un sistema operativo a otro, pero los núcleos generalmente ejecutan el código del núcleo en un espacio de memoria separado de los procesos que ejecutan código de nivel superior( es decir, middleware y código de capa de aplicación).

	
	\item[I/O System Management] Se encarga de cómo vamos a almacenar o permitir que los procesos entre si accedan al espacio de almacenamiento secundario. Lo que queremos es una interfaz estándar para que puedan acceder a todos los espacios de almacenamiento independientemente del hardware y driver que tenga implementado.

	Los dispositivos de E/S también deben compartirse entre los diversos procesos y, por tanto, al igual que con la memoria, el acceso y la asignación de un dispositivo de E/S deben administrarse. 

	\begin{figure}[H]
		\ffigbox[\FBwidth]
		{\caption{Gestión de archivos en Sistemas Embebidos}}
		{\includegraphics[scale=.5]{2021-03-25 11_52_40-2021-03-24 16-59-20.mkv.png}}
	\end{figure}

\end{description}

\subsubsection{Middleware}

Cualquier software del sistema que no es kernel del sistema operativo, controladores de dispositivos o las aplicaciones que se van a desarrollar. Se puede encontrar dentro de los controladores de los dispositivos, del software del SO o independiente sobre estos dos.

\textbf{Razones para usar Middleware}
\begin{itemize}
	\item \textbf{Adaptabilidad - Adaptability:} Permite que el middleware superpuesto y/o aplicaciones integradas se adapten a los cambios en la disponibilidad de los recursos.
	\item \textbf{Conectividad - Connectivity:} Proporciona al middleware superpuesto y/o aplicaciones integradas la capacidad de comunicarse de forma transparente entre aplicaciones de distintos dispositivos, a través una interfaz estándar y amigable.
	\item \textbf{Flexibilidad y Escalabilidad - Flexibility and Scalability:} Permite que el middleware y/o aplicaciones integradas sean configurables y personalizables en términos de funcionalidad según los requisitos de la aplicación.
	\item \textbf{Portabilidad - Portability:} Permite que las aplicaciones integradas y/o middleware superpuestas se ejecuten en diferentes sistemas integrados con diferentes capas de software y/o hardware.
	\item \textbf{Seguridad - Security:} Garantiza que el middleware superpuesto y/o las aplicaciones integradas tengan acceso autorizado a los recursos del sistema.
\end{itemize}

\textbf{Tipos de Middleware}
\begin{itemize}
	\item \textbf{Middleware básico - core:} Tiene un propósito más general y es el más común. Sirve como base para el más complejo y está relacionado con la gestión de sistemas de archivos, las comunicaciones (Controladores de Red) y elementos que permitan virtualizar el funcionamiento.
	\item \textbf{Middleware complejo:} Middleware especifico del mercado, mensajería y comunicaciones complejas, mensajería distribuida y orientada a mensajes, y transacciones distribuidas.
\end{itemize}

Aun así, puede ser middleware \textbf{propietario}, que significa que es un software cerrado respaldado por una empresa que lo licencia a otra para su uso, o puede ser \textbf{abierto}, lo que significa que puede ser implementado y/o licenciado por cualquier parte interesada.

\subsection{Capa de Software de Aplicación}
Se encuentra en la parte superior de la capa de software del sistema y depende del software del sistema, o administra y lo ejecuta. 

Es el software dentro de la capa de aplicación el que define inherentemente que tipo de dispositivo es un sistema integrado, porque la funcionalidad de una aplicación representa al más alto nivel el propósito de ese sistema integrado y realiza la mayor parte de la interacción con los usuarios o administradores de ese dispositivo.

Se pueden dividir en aplicaciones integradas \textbf{especificas del mercado} (implementada en un solo tipo de dispositivo) o de \textbf{propósito general} (se pueden implementar en varios tipos de dispositivos).

\section{Preguntas Test 2}
\begin{itemize}
	\item Seleccione la frase incorrecta con respecto a la definición de sistemas embebidos:
	
	d. PDA o web pads son ejemplos típicos de sistemas embebidos.
	
	\item ¿Por qué POSIX es muy relevante en el área de sistemas operativos integrados?
	
	b. Porque proporciona una interfaz de programación estándar para sistemas operativos embebidos. 
	
	\item Seleccione la afirmación correcta con respecto a las señales/interrupciones del sistema operativo integrado:
	
	b. Las interrupciones son indicadores de que un evento asincrónico ha sido generado por algún evento externo.
	
	\item Seleccione la afirmación correcta con respecto a la interfaz GPIO de Raspberry Pi:
	
	a. Los pines UART se pueden usar para comunicar su Raspberry Pi con otros dispositivos que tengan una interfaz serie.
	
	\item Las placas de desarrollo de microcontroladores...
	
	a. incluyen hardware para programar microcontroladores. 
	
	\item Seleccione la afirmación correcta con respecto a las funcionalidades de los controladores del sistema operativo integrado:
	
	b. La funcionalidad de instalación de hardware permite que otro software instale nuevo hardware sobre la marcha.
	
	\item Seleccionar la afirmación incorrecta:
	
	d. Raspberry Pi está diseñado para la integración de hardware de bajo nivel.
	
	\item Las responsabilidades de gestión de la memoria en el sistema operativo embebido incluye:
	
	a. Determinar qué procesos cargar en el espacio de memoria disponible.
	
	\item Seleccionar la afirmación incorrecta:
	
	?? a. Windows IoT no es un sistema operativo embebido IoT.
	
	c. Debian no es un sistema operativo embebido IoT. 
	
	\item La placa Arduino One no incluye
	
	a. Una ranura para tarjeta Micro SD.
\end{itemize}


\chapter{Tema 5: Protocolos de comunicación de dispositivos con infraestructuras IoT}

\section{Edge Interface, Message Broker y Message Bus}

Se encargan de enrutar y recibir los mensajes de datos que proporcionan los dispositivos IoT, tratan con la transmisión de mensajes con el mundo físico, especialmente dispositivos y sensores Heterogéneos. Se trata de encapsular de una manera estandarizada las maneras, métodos, tecnologías o protocolos de transporte que utilizan los dispositivos IoT para conectarse a internet.

Los protocolos estándar son las herramientas que unen y encapsulan datos sin procesar de un sensor a algo significativo y formateado para que la nube lo acepte.

Los protocolos dominantes son MQTT y CoAP.

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Protocolos de comunicación}}
	{\includegraphics[scale=.5]{2021-04-08 09_06_45-2021-04-07 17-01-12.mkv.png}}
\end{figure}

El problema de usar TCP y HTTP (basado en TCP) es que son muy ricos en información que es una ventaja, pero en el caso de los dispositivos IoT se dispone de recursos limitados, por lo que se preferirá aquellos más ligeros.

\section{Middleware Orientado a Mensajes}

Se basan en una cola de mensajes; CORBA, MQTT, AMQP o XMPP son algunos de los protocolos que lo utilizan.

El servicio de mensajería consta de 3 partes; Publisher (publicador, emisor), Broker (gestor de mensajes, retransmisor) y Subscriber (suscriptor, receptor).
\begin{itemize}
	\item El publicador se conecta y entonces puede enviar datos por un canal (topic).
	\item El broker confirma las conexiones y hace de intermediario, recibiendo y retransmitiendo.
	\item El suscriptor se conecta y pide recibir los mensajes de un canal (topic), y el broker se los irá enviando.
\end{itemize}


\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Comunicación orientada a mensajes}}
	{\includegraphics[scale=.5]{2021-04-08 09_17_44-2021-04-07 17-01-12.mkv.png}
	\includegraphics[scale=.22]{2021-04-08 09_20_09-2021-04-07 17-01-12.mkv.png}}
\end{figure}

El broker hace como intermediario de los publicadores y suscriptores, de esta manera se reduce el acoplamiento y es más fácil escalar el sistema. 

A diferencia de HTTP, no es necesario que el publicador sepa a quien enviárselo, de esta manera se reduce también el consumo de recursos. Al igual los suscriptores no tienen que consultar a un montón de publicadores, solo al broker.

\newpage

\section{Servicio RESTful}

Es la alternativa a los protocolos basados en mensajes. Es asíncrono el intercambio de mensajes.

En un modelo RESTful el servidor posee el estado de un recurso, sabe en qué estado se encuentra.
La recepción de peticiones y la recepción de respuesta es independiente del estado. Se suele utilizar cuando quiero enviar datos a un servidor o los quiero recuperar.

Envía con post y recibe con get, resolviendo el URL.

Utiliza directamente el protocolo HTTP, todos están sobre este, mediante una URL podemos identificar el path.
Al emplear HTTP son protocolos muy exigentes en cuanto a nivel de comunicaciones, requiere mayor cabecera y numero de intercambios de mensajes.

Por ejemplo: CoAP

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Servicio RESTful}}
	{\includegraphics[scale=.7]{2021-04-08 09_36_12-2021-04-07 17-01-12.mkv.png}}
\end{figure}

\section{MQTT - Message Queuing Telemetry Transport}
Protocolo de cola de mensajes, es el protocolo de intercambio de mensajes en el ámbito IoT por excelencia.

Se empezó a trabajar en el en 1993 por IBM, para comunicar dispositivos en lugares remotos, con latencias altas y bajo ancho de banda.

Normalmente hay un suscriptor, un broker y un publicador, que funcionan como se ha descrito arriba (uno crea los topic, otro los gestiona y el ultimo lo recibe).

Se debe tener en cuenta cuál es el tamaño máximo de los mensajes según el proveedor (IBM Watson allows for payload sizes up to 128 KB, while Google supports 256 KB), dado que admite cualquier archivo hay que cuidar de esto, aunque se recomienda que se envíen en formato JSON o en binario, porque son los mejores para conexiones inestables y poco almacenamiento.

\subsection{Desarrollo:}
\begin{itemize}
	\item 1993 - Se comienza a trabajar en él.
	\item 1999 - Andy Standford-Cark y Arlen Nipper fueron los autores de la primera versión del protocolo.
	\item 2010 - MQTT fue lanzado libre de regalías, royalties (se podía utilizar sin pagar).
	\item 2012 - Se lanzo la primera versión de Mosquitto.
	\item 2013 - MQTT-SN que fue especificado y diseñado para funcionar sobre UDP, Zigbee y otros transportes.
	\item 2014 - MQTT se convirtió en un estándar OASIS (de comunicaciones).
	\item 2018 - Se aprobó la versión MQTT v5 (aunque no es la más extendida).
\end{itemize}

\subsection{Objetivos:}
\begin{itemize}
	\item Debe ser fácil de implementar.
	\item Disponer de una calidad de servicio.
	\item Ser ligero y eficiente en ancho de banda, debe dar soporte a dispositivos con poco ancho de banda y consumo de energía.
	\item Ser agnóstico en cuanto al tipo de datos, puede tratar cualquier tipo de datos.
	\item Tener conciencia continua de la sesión.
	\item Abordar problemas de seguridad.
\end{itemize}

\subsection{Estructura de un paquete MQTT}
\begin{itemize}
	\item \textbf{Cabecera:} Indica que tipo de mensaje que estamos mandando y algunas flags.
	\item \textbf{Longitud del paquete}S. 
	\item \textbf{Cabecera adicional (opcional)}: de longitud variable , de uso marginal. 
	\item \textbf{Payload (datos):} Puede tener un tamaño variable, que por protocolo son 256MB máximo, pero dependiendo del proveedor puede ser menor.
\end{itemize}

\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Estructura de un paquete MQTT}}
	{\includegraphics[scale=.5]{f4bd0f8a-2e92-4cdd-abfc-c7b067788d4a.png}}
\end{figure}

\subsection{Tipos de mensajes} 
\subsubsection{CONNECT (cliente a servidor)}
Solicitud de conexión con el broker. 

Solo es obligatorio el identificador de cliente (en nuestro caso lo administra paho), opcionalmente se puede proporcionar nombre de usuario, contraseña, keep alive o última voluntad.

\subsubsection{CONNECT (servidor a cliente)}
Es el ACK de la conexión recibida, responde al CONNECT con un código (RC).
\begin{description}
	\item[0] Conexión satisfactoria.
	\item[1] Conexión rechazada, versión de MQTT inaceptable.	
	\item[2] Conexión rechazada, cliente identificado es UTF-8 y el servidor no lo permite.	
	\item[3] Conexión rechazada, servidor no disponible.	
	\item[4] Conexión rechazada, nombre o contraseña incorrecta.
	\item[5] Conexión rechazada, el cliente no tiene permiso de conexión.
\end{description}

\subsubsection{PUBLISH}
Publicar datos en una rama del canal. 

Necesita un identificador de paquete/mensaje, nombre del canal (topic), nivel de calidad del servicio, retain y los datos (payload) son opcionales.

\subsubsection{SUBSCRIBE}
Suscribirse a un canal.

Requiere identificador de paquete, tópico al que se suscribe, nivel de calidad de servicio. Opcionalmente topic\_2 y qos2. Poniendo llaves en el topic, con el nombre dentro, se suscribe a todos. /uc3m/aulas/{aulas}/temperature

\subsection{Elementos de los mensajes} 

\subsubsection{Last will - Ultima voluntad} 
Es el mensaje que se envía a todos los suscriptores suscritos a ese canal cuando se pierde la conexión de un publicador. Este parámetro se introduce al inicio.

\subsubsection{Retain} 
En el indicamos si queremos que se retenga el mensaje hasta que sea confirmada la recepción por todos los suscriptores.

\subsubsection{Keep alive} 
Indica cada cuanto tiempo se envía un mensaje al suscribirse, si no se recibe uno en 1,5 veces este valor se envía la última voluntad a los suscriptores. El servidor tiene un temporizador para controlar los tiempos.

\textbf{Desconexión inesperada de publicadores:} Se puede deber a quedarse sin batería, internet o no enviar el disconnect. 
\begin{itemize}
	\item Conexión con petición de almacenamiento de "última voluntad"
	\item Almacenamiento de petición de "última voluntad"
	\item confirmación de conexión.
	\item El publicador publica mensajes.
	\item El suscriptor recibe mensajes.
	\item El cliente inesperadamente deja de responder.
	\item El broker envía el mensaje de "última voluntad" a los suscriptores.
\end{itemize}
En caso de que el cliente no tenga nada que enviar envía periódicamente PINGRESP para que no piense que se ha muerto y se reinicie su temporizador.


\subsubsection{QoS - Calidad del servicio}
Son los aseguramientos de entrega de los mensajes enviados por un publicador. Nos permite indicar como queremos que sea la conexión respecto a la recepción de los mensajes.

\begin{description}
\item[0 - Transmisión no asegurada] Es un proceso de entrega de mejor esfuerzo sin que el receptor reconozca un mensaje o el remitente vuelve a intentar transmitir. No se asegura de la entrega de todos los mensajes, si no llega se pierde.

Debe usarse cuando no se necesita la cola de mensajes, para conexiones por cable o sistemas muy limitado en ancho de banda.

	\textbf{Orden de los eventos}
	\begin{enumerate}
	\item El dispositivo publicador se conecta al broker.
	\item El suscriptor se conecta al broker.
	\item El publicador publica un mensaje a través del broker.
	\item El broker envía un mensaje al suscriptor con la información por el publicador.
	\end{enumerate}

	\begin{figure}[H]
		\ffigbox[\FBwidth]
		{\caption{QoS 0}}
		{\includegraphics[scale=.5]{0_1NSybQWdhHvVhnTb.png}}
	\end{figure}

\item[1 - Transmisión asegurada] Asegura la entrega al menos una vez, puede recibirse el mismo mensaje varias veces. Produce más tráfico, el receptor envía un acuse de recibo con una respuesta PUBACK. Debería ser el uso predeterminado, más rápido que el 2 y reduce el costo de transmisión.

	El publicador almacena el mensaje hasta que recibe la confirmación del broker de que se ha enviado al suscriptor. Se desentiende cuando sabe que se ha enviado.
			
	El broker cunado recibe el mensaje lo almacena, envía al suscriptor, avisa del envió al publicador y hasta que no recibe la confirmación de los suscriptores no elimina el mensaje.

	El suscriptor cuando recibe el mensaje confirma la recepción al broker.

	\textbf{Orden de los eventos}
	\begin{enumerate}
	\item El dispositivo publicador A se conecta al broker.
	\item El suscriptor B se conecta al broker.
	\item El publicador publica un mensaje a través del broker.
	\item El publicador A almacena el mensaje enviado.
	\item El broker almacena el mensaje enviado por el publicador A.
	\item El broker envía un mensaje al suscriptor B con la información enviada por el publicador A.
	\item El broker notifica al publicador A que se ha enviado el mensaje.
	\item El publicador A elimina el mensaje enviado.
	\item El suscriptor B confirma que ha recibido el mensaje.
	\item El broker elimina el último mensaje enviado por el publicador A.
	\end{enumerate}

	\begin{figure}[H]
		\ffigbox[\FBwidth]
		{\caption{QoS 1}}
		{\includegraphics[scale=.35]{0_b4pvXUWp6MVnAAFy.png}}
	\end{figure}

\item[2 - Servicio asegurado en aplicaciones] Asegura la entrega, pero solo se recibirá el mensaje una única vez por suscriptor. Informa tanto al remitente como al receptor que se ha transmitido correctamente, se confirman todos los mensajes incluidas las confirmaciones de entregas.

Se usa para aplicaciones de misión crítica, sobre todo en aquellas circunstancias en las que recibir un mensaje duplicado podría provocar fallos.

	\textbf{Orden de los eventos}
	\begin{enumerate}
	\item El dispositivo publicador A se conecta al broker.
	\item El suscriptor B se conecta al broker.
	\item El publicador A almacena el mensaje enviado.
	\item El publicador A publica un mensaje a través del broker.
	\item El broker almacena el mensaje enviado por el publicador A.
	\item El broker envía un mensaje al suscriptor B con la información enviada por el publicador A.
	\item El suscriptor B confirma que ha recibido el mensaje.
	\item El broker envía al publicador A la confirmación de recepción de mensaje.
	\item El publicador A envía la confirmación de la eliminación del mensaje al broker.
	\item El broker informa al suscriptor B de la eliminación del mensaje.
	\item El suscriptor B confirma al broker la recepción del aviso de eliminación del mensaje.
	\item El suscriptor B elimina la información de estado de recepción del mensaje.
	\item El broker confirma al publicador A la confirmación de la recepción del aviso de eliminación del mensaje por parte del suscriptor B.
	\item El broker elimina el último mensaje enviado por el publicador A.
	\item El publicador A elimina el mensaje enviado.
	\end{enumerate}
	
	Error en la imagen: el broker guardaría el mensaje después de recibirlo.
	\begin{figure}[H]
		\ffigbox[\FBwidth]
		{\caption{QoS 2}}
		{\includegraphics[scale=.35]{0_G6zwc_VftJ4AcueS.png}}
	\end{figure}
\end{description}

\section{MQTT-SN - Message Queuing Telemetry Transport for Sensor Networks}
Se utiliza en los casos en los que se quieren conectar sensores que se encuentran en lugares remotos, tienen problemas de batería, tiene una conexión inalámbrica débil o la conexión requiere mucha energía. Para optimizar los recursos.


\subsection{Elementos de estas redes:}
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Estructura MQTT-SN}}
	{\includegraphics[scale=.35]{15a80880-30ad-472a-bf98-254556798207.png}}
\end{figure}
\begin{itemize}
	\item \textbf{Endpoints:} Los distintos sensores o dispositivos.
	\item \textbf{Gateways - Puertas de enlace:} Son los responsables de convertir MQTT-SN a MQTT para enviarlo al router. Se pueden tener retransmisores y repetidores, que permite que llegue más lejos la señal cuando se encuentran en lugares remotos.
\end{itemize}

Los gateways/routers envían periódicamente mensajes broadcast (ADVERTISE) informando de que están disponibles, de esta manera los clientes pueden buscar los gateways a los que se pueden conectar con SEARCHGW, y estos les responderán con GWAINFO con la información de puerta de enlace.

\subsection{Diferencias con el MQTT}
\begin{itemize}
	\item Hay tes mensajes CONNECT en MQTT-SN frente a uno en MQTT, los dos adicionales se utilizan para transportar adicionalmente el tema o el mensaje explícitamente.
	\item MQTT-SN se puede ejecutar en un medio simplificado y UDP.
	\item Los nombres de los temas se reemplazan por mensajes de ID de tema cortos de dos bytes de longitud. Esto es para ayudar con las limitaciones de ancho de banda en las redes inalámbricas.
	\item Los ID de tema predeterminados y los nombres cortos de tema se pueden usar sin ningún registro. Para utilizar esta función, tanto el cliente como el servidor deben utilizar el mismo ID de tema. Los nombres breves de los temas son lo suficientemente cortos como para incluirse en el mensaje PUBLISH.
	\item Se introduce un procedimiento de descubrimiento para ayudar a los clientes y permitirles encontrar las direcciones de red de servidores y puertas de enlace. Pueden existir varias puertas de enlace en la topología y se pueden utilizar para compartir la carga de la comunicación con los clientes.
\end{itemize}

\section{CoAP (Constrained Application Protocol) - Protocolo de Aplicación Restringida}
	Es un estándar del IETF, está pensado para facilitar la conexión entre dos máquinas punto a punto.

	El broker no existe como tal, sino que para conectarte a un servidor necesita conocer su dirección física. Una vez establecida la conexión es hasta 64 veces mejor que su equivalente con HTTP y software similar.
\begin{figure}[H]
	\ffigbox[\FBwidth]
	{\caption{Estructura CoAP}}
	{\includegraphics[scale=.35]{79e6a27f-bae5-4c7b-963a-dcd46c9e26f1.png}}
\end{figure}

\subsection{Requisitos a satisfacer}
	\begin{itemize}
		\item Debe tener una complejidad adecuada que se tienen en una red IoT, con baja capacidad de procesamiento y una 	\item RAM muy limitada. Memoria hasta 256K y RAM de 12K. Reduciendo la sobrecarga de los mensajes de HTTP, pero con un método de direccionamiento exactamente igual al de HTTP.
		\item Es necesario un mecanismo que permita gestionar la cache de solicitudes de recursos recientes, para optimizar.
		\item Tiene que implementar peticiones post, get, put y delete, de manera que permita facilitar y automatizar la creación, eliminación, lectura y actualización de un dispositivo, canal o recursos.
		\item Cada dispositivo debe tener su URI, un identificador único de recurso, similar al de URL.
		\item Periodos de latencias muy bajos.
		\item Tiene que trabajar sobre UDP, para aligerar el protocolo.
	\end{itemize}

\subsection{Mecanismos para la conexión}
Para que un dispositivo se conecte a un sensor, se debe realizar una petición directa al sensor.

Se utiliza el protocolo coap (coap://) en vez de http, con un nombre de URL que represente a los dispositivos (myhome.in:5683), una subdirección dentro de la URL para indicar el dispositivo (nest\_livingroom) y por último el nombre del parámetro de control del dispositivo (temp). Este último se podría completar con las distintas peticiones get, put, post o delete, que nos devuelven los datos o el código de error correspondiente (los códigos están reducidos).

$coap://myhome.in:5683/nest\_livingroom/temp$

\subsection{Diferencias con MQTT}
\begin{itemize}
	\item No hay como tal broker en CoAP de manera general, pero se podría tener un observador en el medio que gestione las publicaciones.
	\item Es más ligero CoAP.
	\item Se pueden referenciar los recursos con si fuera una URI, para esto se necesita un resolvedor.
	\item El intercambio de mensajes es totalmente asíncrono.
\end{itemize}



\chapter{Recursos}
\href{https://learning.oreilly.com/playlists/5a6c045f-e39c-465e-9e7c-60dcbb12aebb}{Lista de libros de referencia}

\section{Tema 1: Arquitectura de Sistemas IoT}
\href{https://learning.oreilly.com/library/view/internet-of-things/9781788470599/a7f866bd-4ac8-47f3-a175-0f10d91a5ce2.xhtml}{Definición de Internet de las Cosas}

\href{https://learning.oreilly.com/library/view/internet-of-things/9781119456742/part04.xhtml\#part}{Aplicaciones Actuales de Internet de las Cosas}

\href{https://learning.oreilly.com/library/view/build-your-own/9781484244982/html/474034_1_En_2_Chapter.xhtml}{Arquitectura de Sistemas de Internet de las Cosas}

\section{Tema 2: Sensores y Actuadores}
\href{https://learning.oreilly.com/library/view/internet-of-things/9781788470599/d39be056-b166-476e-868e-c415e4dfa886.xhtml}{Introducción a Sensores y Actuadores} Hasta la sección 'Up to Functional examples (putting it all together)' incluida

\section{Tema 3: Sistemas operativos embebidos para Dispositivos IoT}
\href{https://learning.oreilly.com/library/view/embedded-systems-architecture/9780123821966/xhtml/CHP001.html#CHP001titl}{Introducción a los Sistemas Embebidos} Solo capítulo 1

\href{https://learning.oreilly.com/library/view/embedded-systems-architecture/9780123821966/xhtml/CHP009.html#CHP009titl}{Sistemas Operativos Embebidos} Capítulo 9

\href{https://learning.oreilly.com/library/view/embedded-systems-architecture/9780123821966/xhtml/CHP008.html#CHP008titl}{Drivers de Dispositivos} Hasta el encabezado "8.1 Example 1: Device Drivers for Interrupt Handling"

\href{https://learning.oreilly.com/library/view/embedded-systems-architecture/9780123821966/xhtml/CHP010.html#CHP010titl}{Middleware} Secciones 10.1 y 10.2

\section{Tema 5: Protocolos de comunicación de dispositivos con infraestructuras IoT}
\href{https://learning.oreilly.com/library/view/internet-of-things/9781788470599/b34f5cd8-115c-490c-b5c2-38a3a966a65a.xhtml}{Proctocolos de comunicación IoT}

\end{document}